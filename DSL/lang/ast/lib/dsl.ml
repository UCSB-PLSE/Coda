open Ast
let tf = TRef (TF, QTrue)
let tfq q = TRef (TF, q)
let tint = TRef (TInt, QTrue)
let tbool = TRef (TBool, QTrue)
let lam x e = Lam (x, e)
let lama x t e = LamA (x, t, e)
let ascribe e t = Ascribe (e, t)
let dummy x t = AscribeUnsafe (Var x, t)
let app f x = App (f, x)
let rec apps f = function [] -> f | x::xs -> apps (app f x) xs
let dummy_apps s f es = apps (dummy s f) es
let tfun x t1 t2 = TFun (x, t1, t2)
let tprod ts q_opt = TDProd (ts, q_opt)
let ttuple ts = TTuple ts
let re tb e = TRef (tb, QExpr e)
let opp e = Opp e
let add e1 e2 = Binop (Add, e1, e2)
let sub e1 e2 = Binop (Sub, e1, e2)
let mul e1 e2 = Binop (Mul, e1, e2)
let pow e1 e2 = Binop (Pow, e1, e2)
let eq e1 e2 = Comp (Eq, e1, e2)
let leq e1 e2 = Comp (Leq, e1, e2)
let lt e1 e2 = Comp (Lt, e1, e2)
let bnot e = Not e
let bor e1 e2 = Boolop (Or, e1, e2)
let band e1 e2 = Boolop (And, e1, e2)
let imply e1 e2 = Boolop (Imply, e1, e2)
let ite e1 e2 e3 = band (imply e1 e2) (imply (bnot e1) e3)
let assert_eq e1 e2 = SAssert (eq e1 e2)
let v x = Var x
let nu = Var "Î½"
let fc n = Const (CF n)
let zc n = Const (CInt n)
let f0 = fc 0
let f1 = fc 1
let f2 = fc 2
let z0 = zc 0
let z1 = zc 1
let z2 = zc 2
let btrue = Const (CBool true)
let bfalse = Const (CBool false)
let tf_binary = TRef (TF, QExpr (bor (eq nu f0) (eq nu f1)))

let tmake es = TMake es
let tget e n = TGet (e, n)

let slet x e = SLet (x, e)
let elet x e1 e2 = LetIn (x, e1, e2)
let sum si es ee eb = Sum (si, es, ee, eb)
let get xs i = ArrayOp (Get, xs, i)
let cons x xs = ArrayOp (Cons, x, xs)
let take n xs = ArrayOp (Take, n, xs)
let drop n xs = ArrayOp (Drop, n, xs)
let toBigInt (i: string) (n: expr) (k: expr) (xs: expr) : expr = 
  let ei = v i in
  sum i z0 k (mul (get xs ei) (pow f2 (mul n ei)))
let z_range l r = TRef (TInt, QExpr (band (leq l nu) (leq nu r)))
let toSZ e = Fn (ToSZ, e)
let toUZ e = Fn (ToUZ, e)