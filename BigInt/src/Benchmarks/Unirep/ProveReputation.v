(** * DSL benchmark: Semaphore *)

Require Import Coq.Lists.List.
Require Import Coq.micromega.Lia.
Require Import Coq.Init.Peano.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Arith.Compare_dec.
Require Import Coq.PArith.BinPosDef.
Require Import Coq.ZArith.BinInt Coq.ZArith.ZArith Coq.ZArith.Zdiv Coq.ZArith.Znumtheory Coq.NArith.NArith. (* import Zdiv before Znumtheory *)
Require Import Coq.NArith.Nnat.

Require Import Crypto.Spec.ModularArithmetic.
Require Import Crypto.Arithmetic.PrimeFieldTheorems Crypto.Algebra.Field.
Require Import Crypto.Util.Decidable. (* Crypto.Util.Notations. *)
Require Import Coq.setoid_ring.Ring_theory Coq.setoid_ring.Field_theory Coq.setoid_ring.Field_tac.

From Circom Require Import Circom Util Default Tuple ListUtil LibTactics Simplify Repr Coda.
From Circom.CircomLib Require Import Bitify.

Local Coercion N.of_nat : nat >-> N.
Local Coercion Z.of_nat : nat >-> Z.

Local Open Scope list_scope.
Local Open Scope F_scope.
Local Open Scope Z_scope.
Local Open Scope circom_scope.
Local Open Scope tuple_scope.

Definition Poseidon (nInputs : nat) (inputs : list F) : F. Admitted.

Axiom Poseidon_2 : forall inputs : list F,
  length inputs = 2%nat ->
  Poseidon 2%nat inputs = Poseidon 2%nat ((inputs!0%nat)::(inputs!1%nat)::nil).


#[global]Hint Extern 10 (Forall _ (firstn _ _)) => apply Forall_firstn: core.
#[global]Hint Extern 10  => match goal with
   | [ |- context[List_nth_Default _ _] ] => unfold_default end: core.
   #[global]Hint Extern 10  => match goal with
   | [ |- context[List.nth  _ _ _] ] => apply Forall_nth end: core.
#[global]Hint Extern 10 => match goal with
  [ |- context[length _] ] => rewrite_length end: core.
#[global]Hint Extern 10 (Forall _ (skipn _ _)) => apply Forall_skipn: core.

#[global]Hint Extern 10 (Forall _ (_ :: _)) => constructor: core.
#[global]Hint Extern 10 (Z.of_N (N.of_nat _)) => rewrite nat_N_Z: core.
#[global]Hint Extern 10  => repeat match goal with
  [ H: context[Z.of_N (N.of_nat _)] |- _] => rewrite nat_N_Z in H end: core.

#[global]Hint Extern 10 (_ < _) => lia: core.
#[global]Hint Extern 10 (_ < _)%nat => lia: core.
#[global]Hint Extern 10 (_ <= _) => lia: core.
#[global]Hint Extern 10 (_ <= _)%nat => lia: core.
#[global]Hint Extern 10 (_ > _) => lia: core.
#[global]Hint Extern 10 (_ > _)%nat => lia: core.
#[global]Hint Extern 10 (_ >= _) => lia: core.
#[global]Hint Extern 10 (_ >= _)%nat => lia: core.
#[global]Hint Extern 10 (S _ = S _) => f_equal: core.

Definition zip {A B} (xs : list A) (ys : list B) := combine xs ys.

(* Note: This is a placeholder implementation that lets us prove many
trivial and even some nontrivial MerkleTreeInclusionProof obligations *)
Definition MrklTreeInclPfHash (xs : list (F * F)) (init : F) := 
  fold_left (fun (y:F) (x:(F*F)) => if dec (fst x = 0%F) then (Poseidon 2%nat (y :: (snd x) :: nil)) else (Poseidon 2%nat ((snd x):: y :: nil))) 
                       xs init.

Definition u_state_tree_leaf (a:list F) (b:F) := fold_left (fun (x:F) (y:F) => Poseidon 2%nat (x::y::nil)) a b.

Axiom q_rng: (38446744073709551615 < q).

Lemma ProveReputation_obligation0: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x0 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x1 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x2 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> ((v = 64%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation1_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x3 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x4 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x5 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> ((v = min_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation2: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x6 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x7 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x8 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x9 => ((x9 = 0%F) \/ (x9 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> True -> ((v = 64%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation3_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x10 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x11 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x12 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x13 => ((x13 = 0%F) \/ (x13 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> True -> ((v = max_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation4_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x14 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x15 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x16 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x17 => ((x17 = 0%F) \/ (x17 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x18 => ((x18 = 0%F) \/ (x18 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> True -> ((v = prove_graffiti) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation5_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x19 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x20 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x21 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x22 => ((x22 = 0%F) \/ (x22 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x23 => ((x23 = 0%F) \/ (x23 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> True -> ((v = prove_graffiti) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation6_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x24 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x25 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x26 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x27 => ((x27 = 0%F) \/ (x27 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x28 => ((x28 = 0%F) \/ (x28 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> True -> ((v = 1%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation7_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x29 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x30 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x31 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x32 => ((x32 = 0%F) \/ (x32 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x33 => ((x33 = 0%F) \/ (x33 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> True -> ((v = (prove_graffiti - 1%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation8_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x34 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x35 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x36 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x37 => ((x37 = 0%F) \/ (x37 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x38 => ((x38 = 0%F) \/ (x38 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> True -> ((v = prove_min_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation9_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x39 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x40 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x41 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x42 => ((x42 = 0%F) \/ (x42 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x43 => ((x43 = 0%F) \/ (x43 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> True -> ((v = prove_min_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation10_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x44 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x45 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x46 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x47 => ((x47 = 0%F) \/ (x47 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x48 => ((x48 = 0%F) \/ (x48 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> True -> ((v = 1%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation11_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x49 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x50 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x51 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x52 => ((x52 = 0%F) \/ (x52 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x53 => ((x53 = 0%F) \/ (x53 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> True -> ((v = (prove_min_rep - 1%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation12_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x54 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x55 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x56 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x57 => ((x57 = 0%F) \/ (x57 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x58 => ((x58 = 0%F) \/ (x58 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_max_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation13_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x59 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x60 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x61 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x62 => ((x62 = 0%F) \/ (x62 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x63 => ((x63 = 0%F) \/ (x63 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_max_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation14_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x64 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x65 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x66 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x67 => ((x67 = 0%F) \/ (x67 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x68 => ((x68 = 0%F) \/ (x68 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 1%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation15_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x69 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x70 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x71 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x72 => ((x72 = 0%F) \/ (x72 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x73 => ((x73 = 0%F) \/ (x73 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (prove_max_rep - 1%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation16_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x74 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x75 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x76 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x77 => ((x77 = 0%F) \/ (x77 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x78 => ((x78 = 0%F) \/ (x78 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_zero_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation17_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x79 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x80 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x81 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x82 => ((x82 = 0%F) \/ (x82 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x83 => ((x83 = 0%F) \/ (x83 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_zero_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation18_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x84 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x85 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x86 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x87 => ((x87 = 0%F) \/ (x87 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x88 => ((x88 = 0%F) \/ (x88 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 1%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation19_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x89 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x90 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x91 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x92 => ((x92 = 0%F) \/ (x92 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x93 => ((x93 = 0%F) \/ (x93 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (prove_zero_rep - 1%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation20_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x94 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x95 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x96 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x97 => ((x97 = 0%F) \/ (x97 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x98 => ((x98 = 0%F) \/ (x98 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_graffiti) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation21_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x99 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x100 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x101 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x102 => ((x102 = 0%F) \/ (x102 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x103 => ((x103 = 0%F) \/ (x103 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 2%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation22: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x104 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x105 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x106 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x107 => ((x107 = 0%F) \/ (x107 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x108 => ((x108 = 0%F) \/ (x108 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 131%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation23_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x109 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x110 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x111 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x112 => ((x112 = 0%F) \/ (x112 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x113 => ((x113 = 0%F) \/ (x113 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (2%F ^ 131%nat)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation24_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x114 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x115 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x116 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x117 => ((x117 = 0%F) \/ (x117 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x118 => ((x118 = 0%F) \/ (x118 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (prove_graffiti * (2%F ^ 131%nat)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation25_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x119 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x120 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x121 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x122 => ((x122 = 0%F) \/ (x122 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x123 => ((x123 = 0%F) \/ (x123 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_zero_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation26_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x124 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x125 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x126 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x127 => ((x127 = 0%F) \/ (x127 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x128 => ((x128 = 0%F) \/ (x128 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 2%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation27: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x129 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x130 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x131 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x132 => ((x132 = 0%F) \/ (x132 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x133 => ((x133 = 0%F) \/ (x133 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 130%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation28_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x134 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x135 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x136 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x137 => ((x137 = 0%F) \/ (x137 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x138 => ((x138 = 0%F) \/ (x138 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (2%F ^ 130%nat)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation29_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x139 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x140 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x141 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x142 => ((x142 = 0%F) \/ (x142 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x143 => ((x143 = 0%F) \/ (x143 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (prove_zero_rep * (2%F ^ 130%nat)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation30_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x144 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x145 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x146 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x147 => ((x147 = 0%F) \/ (x147 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x148 => ((x148 = 0%F) \/ (x148 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_max_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation31_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x149 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x150 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x151 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x152 => ((x152 = 0%F) \/ (x152 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x153 => ((x153 = 0%F) \/ (x153 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 2%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation32: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x154 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x155 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x156 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x157 => ((x157 = 0%F) \/ (x157 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x158 => ((x158 = 0%F) \/ (x158 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 129%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation33_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x159 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x160 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x161 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x162 => ((x162 = 0%F) \/ (x162 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x163 => ((x163 = 0%F) \/ (x163 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (2%F ^ 129%nat)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation34_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x164 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x165 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x166 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x167 => ((x167 = 0%F) \/ (x167 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x168 => ((x168 = 0%F) \/ (x168 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (prove_max_rep * (2%F ^ 129%nat)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation35_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x169 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x170 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x171 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x172 => ((x172 = 0%F) \/ (x172 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x173 => ((x173 = 0%F) \/ (x173 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = prove_min_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation36_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x174 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x175 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x176 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x177 => ((x177 = 0%F) \/ (x177 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x178 => ((x178 = 0%F) \/ (x178 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 2%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation37: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x179 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x180 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x181 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x182 => ((x182 = 0%F) \/ (x182 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x183 => ((x183 = 0%F) \/ (x183 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 128%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation38_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x184 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x185 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x186 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x187 => ((x187 = 0%F) \/ (x187 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x188 => ((x188 = 0%F) \/ (x188 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (2%F ^ 128%nat)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation39_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x189 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x190 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x191 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x192 => ((x192 = 0%F) \/ (x192 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x193 => ((x193 = 0%F) \/ (x193 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (prove_min_rep * (2%F ^ 128%nat)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation40_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x194 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x195 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x196 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x197 => ((x197 = 0%F) \/ (x197 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x198 => ((x198 = 0%F) \/ (x198 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = max_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation41_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x199 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x200 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x201 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x202 => ((x202 = 0%F) \/ (x202 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x203 => ((x203 = 0%F) \/ (x203 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 2%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation42: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x204 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x205 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x206 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x207 => ((x207 = 0%F) \/ (x207 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x208 => ((x208 = 0%F) \/ (x208 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = 64%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation43_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x209 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x210 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x211 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x212 => ((x212 = 0%F) \/ (x212 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x213 => ((x213 = 0%F) \/ (x213 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (2%F ^ 64%nat)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation44_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x214 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x215 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x216 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x217 => ((x217 = 0%F) \/ (x217 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x218 => ((x218 = 0%F) \/ (x218 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = (max_rep * (2%F ^ 64%nat)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation45_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x219 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x220 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x221 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x222 => ((x222 = 0%F) \/ (x222 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x223 => ((x223 = 0%F) \/ (x223 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = min_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation46_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x224 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x225 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x226 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x227 => ((x227 = 0%F) \/ (x227 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x228 => ((x228 = 0%F) \/ (x228 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation47_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x229 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x230 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x231 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x232 => ((x232 = 0%F) \/ (x232 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x233 => ((x233 = 0%F) \/ (x233 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation48_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x234 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x235 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x236 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x237 => ((x237 = 0%F) \/ (x237 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x238 => ((x238 = 0%F) \/ (x238 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation49_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x239 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x240 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x241 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x242 => ((x242 = 0%F) \/ (x242 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x243 => ((x243 = 0%F) \/ (x243 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> True -> ((v = ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation50: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x244 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x245 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x246 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x247 => ((x247 = 0%F) \/ (x247 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x248 => ((x248 = 0%F) \/ (x248 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> True -> ((v = 48%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation51_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x249 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x250 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x251 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x252 => ((x252 = 0%F) \/ (x252 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x253 => ((x253 = 0%F) \/ (x253 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> True -> ((v = epoch) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation52: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x254 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x255 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x256 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x257 => ((x257 = 0%F) \/ (x257 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x258 => ((x258 = 0%F) \/ (x258 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x259 => ((x259 = 0%F) \/ (x259 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> True -> ((v = 160%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation53_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x260 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x261 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x262 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x263 => ((x263 = 0%F) \/ (x263 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x264 => ((x264 = 0%F) \/ (x264 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x265 => ((x265 = 0%F) \/ (x265 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> True -> ((v = attester_id) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation54: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x266 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x267 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x268 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x269 => ((x269 = 0%F) \/ (x269 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x270 => ((x270 = 0%F) \/ (x270 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x271 => ((x271 = 0%F) \/ (x271 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x272 => ((x272 = 0%F) \/ (x272 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((((0%nat <= v) /\ ((v <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z))) /\ (v = STATE_TREE_DEPTH)) -> ((0%nat <= v) /\ ((v <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation55: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x273 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x274 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x275 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x276 => ((x276 = 0%F) \/ (x276 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x277 => ((x277 = 0%F) \/ (x277 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x278 => ((x278 = 0%F) \/ (x278 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x279 => ((x279 = 0%F) \/ (x279 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((((0%nat <= v) /\ ((v <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z))) /\ (v = EPOCH_KEY_NONCE_PER_EPOCH)) -> ((0%nat <= v) /\ ((v <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation56: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x280 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x281 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x282 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x283 => ((x283 = 0%F) \/ (x283 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x284 => ((x284 = 0%F) \/ (x284 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x285 => ((x285 = 0%F) \/ (x285 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x286 => ((x286 = 0%F) \/ (x286 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> (((0%nat <= v) /\ (v = FIELD_COUNT)) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation57: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x287 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x288 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x289 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x290 => ((x290 = 0%F) \/ (x290 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x291 => ((x291 = 0%F) \/ (x291 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x292 => ((x292 = 0%F) \/ (x292 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x293 => ((x293 = 0%F) \/ (x293 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> Forall (fun x294 => True) v -> True -> ((((length v) = STATE_TREE_DEPTH) /\ (v = state_tree_indexes)) -> ((length v) = STATE_TREE_DEPTH)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation58: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x295 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x296 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x297 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x298 => ((x298 = 0%F) \/ (x298 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x299 => ((x299 = 0%F) \/ (x299 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x300 => ((x300 = 0%F) \/ (x300 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x301 => ((x301 = 0%F) \/ (x301 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> Forall (fun x302 => True) v -> True -> ((((length v) = STATE_TREE_DEPTH) /\ (v = state_tree_elements)) -> ((length v) = STATE_TREE_DEPTH)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation59_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x303 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x304 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x305 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x306 => ((x306 = 0%F) \/ (x306 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x307 => ((x307 = 0%F) \/ (x307 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x308 => ((x308 = 0%F) \/ (x308 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x309 => ((x309 = 0%F) \/ (x309 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = identity_secret) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation60_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x310 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x311 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x312 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x313 => ((x313 = 0%F) \/ (x313 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x314 => ((x314 = 0%F) \/ (x314 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x315 => ((x315 = 0%F) \/ (x315 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x316 => ((x316 = 0%F) \/ (x316 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = reveal_nonce) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation61_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x317 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x318 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x319 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x320 => ((x320 = 0%F) \/ (x320 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x321 => ((x321 = 0%F) \/ (x321 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x322 => ((x322 = 0%F) \/ (x322 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x323 => ((x323 = 0%F) \/ (x323 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = attester_id) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation62_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x324 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x325 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x326 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x327 => ((x327 = 0%F) \/ (x327 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x328 => ((x328 = 0%F) \/ (x328 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x329 => ((x329 = 0%F) \/ (x329 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x330 => ((x330 = 0%F) \/ (x330 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = epoch) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation63_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x331 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x332 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x333 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x334 => ((x334 = 0%F) \/ (x334 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x335 => ((x335 = 0%F) \/ (x335 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x336 => ((x336 = 0%F) \/ (x336 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x337 => ((x337 = 0%F) \/ (x337 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = nonce) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation64: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x338 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x339 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x340 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x341 => ((x341 = 0%F) \/ (x341 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x342 => ((x342 = 0%F) \/ (x342 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x343 => ((x343 = 0%F) \/ (x343 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x344 => ((x344 = 0%F) \/ (x344 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> Forall (fun x345 => True) v -> True -> ((((length v) = FIELD_COUNT) /\ (v = data)) -> ((length v) = FIELD_COUNT)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation65_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x346 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x347 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x348 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x349 => ((x349 = 0%F) \/ (x349 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x350 => ((x350 = 0%F) \/ (x350 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x351 => ((x351 = 0%F) \/ (x351 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x352 => ((x352 = 0%F) \/ (x352 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = sig_data) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation66: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x353 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x354 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x355 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x356 => ((x356 = 0%F) \/ (x356 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x357 => ((x357 = 0%F) \/ (x357 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x358 => ((x358 = 0%F) \/ (x358 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x359 => ((x359 = 0%F) \/ (x359 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x360,x361,x362) => (x360 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x360,x361,x362) => (x361 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x360,x361,x362) => (x362 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x360,x361,x362) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> True -> ((v = 64%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation67_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x363 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x364 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x365 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x366 => ((x366 = 0%F) \/ (x366 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x367 => ((x367 = 0%F) \/ (x367 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x368 => ((x368 = 0%F) \/ (x368 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x369 => ((x369 = 0%F) \/ (x369 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x370,x371,x372) => (x370 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x370,x371,x372) => (x371 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x370,x371,x372) => (x372 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x370,x371,x372) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> True -> ((v = (data!0%nat)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation68: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x373 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x374 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x375 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x376 => ((x376 = 0%F) \/ (x376 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x377 => ((x377 = 0%F) \/ (x377 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x378 => ((x378 = 0%F) \/ (x378 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x379 => ((x379 = 0%F) \/ (x379 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x380,x381,x382) => (x380 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x380,x381,x382) => (x381 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x380,x381,x382) => (x382 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x380,x381,x382) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x383 => ((x383 = 0%F) \/ (x383 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> True -> ((v = 64%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation69_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x384 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x385 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x386 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x387 => ((x387 = 0%F) \/ (x387 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x388 => ((x388 = 0%F) \/ (x388 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x389 => ((x389 = 0%F) \/ (x389 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x390 => ((x390 = 0%F) \/ (x390 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x391,x392,x393) => (x391 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x391,x392,x393) => (x392 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x391,x392,x393) => (x393 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x391,x392,x393) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x394 => ((x394 = 0%F) \/ (x394 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> True -> ((v = (data!1%nat)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation70: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x395 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x396 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x397 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x398 => ((x398 = 0%F) \/ (x398 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x399 => ((x399 = 0%F) \/ (x399 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x400 => ((x400 = 0%F) \/ (x400 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x401 => ((x401 = 0%F) \/ (x401 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x402,x403,x404) => (x402 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x402,x403,x404) => (x403 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x402,x403,x404) => (x404 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x402,x403,x404) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x405 => ((x405 = 0%F) \/ (x405 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x406 => ((x406 = 0%F) \/ (x406 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> True -> ((v = 66%nat) -> ((0%nat <= v) /\ (v <= (C.k - 1%nat)%Z))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation71: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x407 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x408 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x409 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x410 => ((x410 = 0%F) \/ (x410 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x411 => ((x411 = 0%F) \/ (x411 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x412 => ((x412 = 0%F) \/ (x412 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x413 => ((x413 = 0%F) \/ (x413 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x414,x415,x416) => (x414 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x414,x415,x416) => (x415 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x414,x415,x416) => (x416 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x414,x415,x416) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x417 => ((x417 = 0%F) \/ (x417 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x418 => ((x418 = 0%F) \/ (x418 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> True -> ((v = (data!0%nat)) -> (((^ v) + 1%nat)%Z < (2%nat ^ 66%nat)%Z)).
Proof. 
  intros.
  intuition. subst.
  rewrite <- H34.
  pose proof (as_le_f_lt data_0_check).
  rewrite H56 in *.
  hammer. 
Qed.

Lemma ProveReputation_obligation72_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x419 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x420 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x421 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x422 => ((x422 = 0%F) \/ (x422 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x423 => ((x423 = 0%F) \/ (x423 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x424 => ((x424 = 0%F) \/ (x424 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x425 => ((x425 = 0%F) \/ (x425 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x426,x427,x428) => (x426 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x426,x427,x428) => (x427 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x426,x427,x428) => (x428 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x426,x427,x428) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x429 => ((x429 = 0%F) \/ (x429 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x430 => ((x430 = 0%F) \/ (x430 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> True -> ((v = (data!1%nat)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation73_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x431 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x432 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x433 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x434 => ((x434 = 0%F) \/ (x434 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x435 => ((x435 = 0%F) \/ (x435 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x436 => ((x436 = 0%F) \/ (x436 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x437 => ((x437 = 0%F) \/ (x437 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x438,x439,x440) => (x438 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x438,x439,x440) => (x439 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x438,x439,x440) => (x440 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x438,x439,x440) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x441 => ((x441 = 0%F) \/ (x441 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x442 => ((x442 = 0%F) \/ (x442 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> True -> ((v = min_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation74: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x443 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x444 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x445 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x446 => ((x446 = 0%F) \/ (x446 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x447 => ((x447 = 0%F) \/ (x447 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x448 => ((x448 = 0%F) \/ (x448 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x449 => ((x449 = 0%F) \/ (x449 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x450,x451,x452) => (x450 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x450,x451,x452) => (x451 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x450,x451,x452) => (x452 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x450,x451,x452) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x453 => ((x453 = 0%F) \/ (x453 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x454 => ((x454 = 0%F) \/ (x454 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> True -> ((v = ((data!1%nat) + min_rep)%F) -> ((^ v) <= ((2%nat ^ 66%nat)%Z - 1%nat)%Z)).
Proof.
intros.
intuition. subst.
rewrite <- H43.
pose proof (as_le_f_lt data_1_check).
rewrite H57 in *.
pose proof (as_le_f_lt min_rep_bits).
rewrite H52 in *. simpl in *.
unwrap_C.
rewrite Zmod_small;try lia. pose proof q_rng.
split;try
hammer.
pose proof (F_to_Z_nonneg (as_le_f data_1_check)).
pose proof (F_to_Z_nonneg (as_le_f min_rep_bits)).
hammer.
Qed.

Lemma ProveReputation_obligation75_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x455 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x456 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x457 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x458 => ((x458 = 0%F) \/ (x458 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x459 => ((x459 = 0%F) \/ (x459 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x460 => ((x460 = 0%F) \/ (x460 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x461 => ((x461 = 0%F) \/ (x461 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x462,x463,x464) => (x462 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x462,x463,x464) => (x463 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x462,x463,x464) => (x464 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x462,x463,x464) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x465 => ((x465 = 0%F) \/ (x465 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x466 => ((x466 = 0%F) \/ (x466 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> True -> ((v = prove_min_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation76: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x467 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x468 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x469 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x470 => ((x470 = 0%F) \/ (x470 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x471 => ((x471 = 0%F) \/ (x471 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x472 => ((x472 = 0%F) \/ (x472 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x473 => ((x473 = 0%F) \/ (x473 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x474,x475,x476) => (x474 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x474,x475,x476) => (x475 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x474,x475,x476) => (x476 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x474,x475,x476) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x477 => ((x477 = 0%F) \/ (x477 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x478 => ((x478 = 0%F) \/ (x478 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> (prove_min_rep = 0%F)) /\ ((v = 0%F) -> ~(prove_min_rep = 0%F)))) /\ (v = if_not_prove_min_rep)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation77: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x479 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x480 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x481 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x482 => ((x482 = 0%F) \/ (x482 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x483 => ((x483 = 0%F) \/ (x483 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x484 => ((x484 = 0%F) \/ (x484 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x485 => ((x485 = 0%F) \/ (x485 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x486,x487,x488) => (x486 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x486,x487,x488) => (x487 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x486,x487,x488) => (x488 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x486,x487,x488) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x489 => ((x489 = 0%F) \/ (x489 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x490 => ((x490 = 0%F) \/ (x490 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((v = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) /\ (v = min_rep_check)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation78: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x491 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x492 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x493 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x494 => ((x494 = 0%F) \/ (x494 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x495 => ((x495 = 0%F) \/ (x495 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x496 => ((x496 = 0%F) \/ (x496 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x497 => ((x497 = 0%F) \/ (x497 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x498,x499,x500) => (x498 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x498,x499,x500) => (x499 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x498,x499,x500) => (x500 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x498,x499,x500) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x501 => ((x501 = 0%F) \/ (x501 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x502 => ((x502 = 0%F) \/ (x502 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> True -> ((v = 66%nat) -> ((0%nat <= v) /\ (v <= (C.k - 1%nat)%Z))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation79: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x503 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x504 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x505 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x506 => ((x506 = 0%F) \/ (x506 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x507 => ((x507 = 0%F) \/ (x507 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x508 => ((x508 = 0%F) \/ (x508 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x509 => ((x509 = 0%F) \/ (x509 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x510,x511,x512) => (x510 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x510,x511,x512) => (x511 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x510,x511,x512) => (x512 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x510,x511,x512) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x513 => ((x513 = 0%F) \/ (x513 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x514 => ((x514 = 0%F) \/ (x514 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> True -> ((v = (data!1%nat)) -> (((^ v) + 1%nat)%Z < (2%nat ^ 66%nat)%Z)).
Proof. 
intros. subst. destruct H45. rewrite <- H5.
pose proof (as_le_f_lt data_1_check).
rewrite H9 in *.
hammer. 
Qed.

Lemma ProveReputation_obligation80_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x515 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x516 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x517 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x518 => ((x518 = 0%F) \/ (x518 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x519 => ((x519 = 0%F) \/ (x519 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x520 => ((x520 = 0%F) \/ (x520 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x521 => ((x521 = 0%F) \/ (x521 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x522,x523,x524) => (x522 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x522,x523,x524) => (x523 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x522,x523,x524) => (x524 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x522,x523,x524) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x525 => ((x525 = 0%F) \/ (x525 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x526 => ((x526 = 0%F) \/ (x526 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> True -> ((v = (data!0%nat)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation81_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x527 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x528 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x529 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x530 => ((x530 = 0%F) \/ (x530 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x531 => ((x531 = 0%F) \/ (x531 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x532 => ((x532 = 0%F) \/ (x532 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x533 => ((x533 = 0%F) \/ (x533 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x534,x535,x536) => (x534 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x534,x535,x536) => (x535 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x534,x535,x536) => (x536 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x534,x535,x536) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x537 => ((x537 = 0%F) \/ (x537 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x538 => ((x538 = 0%F) \/ (x538 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> True -> ((v = max_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation82: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x539 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x540 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x541 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x542 => ((x542 = 0%F) \/ (x542 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x543 => ((x543 = 0%F) \/ (x543 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x544 => ((x544 = 0%F) \/ (x544 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x545 => ((x545 = 0%F) \/ (x545 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x546,x547,x548) => (x546 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x546,x547,x548) => (x547 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x546,x547,x548) => (x548 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x546,x547,x548) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x549 => ((x549 = 0%F) \/ (x549 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x550 => ((x550 = 0%F) \/ (x550 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> True -> ((v = ((data!0%nat) + max_rep)%F) -> ((^ v) <= ((2%nat ^ 66%nat)%Z - 1%nat)%Z)).
Proof. 
intros. clear H47. clear H48. clear H46.
intuition. subst.
rewrite <- H34.
pose proof (as_le_f_lt data_0_check).
rewrite H57 in *.
pose proof (as_le_f_lt max_rep_bits).
rewrite H54 in *. simpl in *.
unwrap_C.
rewrite Zmod_small;try lia. pose proof q_rng.
split;try
hammer.
pose proof (F_to_Z_nonneg (as_le_f data_0_check)).
pose proof (F_to_Z_nonneg (as_le_f max_rep_bits)).
hammer.
Qed.

Lemma ProveReputation_obligation83_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x551 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x552 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x553 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x554 => ((x554 = 0%F) \/ (x554 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x555 => ((x555 = 0%F) \/ (x555 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x556 => ((x556 = 0%F) \/ (x556 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x557 => ((x557 = 0%F) \/ (x557 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x558,x559,x560) => (x558 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x558,x559,x560) => (x559 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x558,x559,x560) => (x560 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x558,x559,x560) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x561 => ((x561 = 0%F) \/ (x561 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x562 => ((x562 = 0%F) \/ (x562 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> True -> ((v = prove_max_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation84: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x563 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x564 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x565 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x566 => ((x566 = 0%F) \/ (x566 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x567 => ((x567 = 0%F) \/ (x567 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x568 => ((x568 = 0%F) \/ (x568 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x569 => ((x569 = 0%F) \/ (x569 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x570,x571,x572) => (x570 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x570,x571,x572) => (x571 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x570,x571,x572) => (x572 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x570,x571,x572) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x573 => ((x573 = 0%F) \/ (x573 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x574 => ((x574 = 0%F) \/ (x574 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> (prove_max_rep = 0%F)) /\ ((v = 0%F) -> ~(prove_max_rep = 0%F)))) /\ (v = if_not_prove_max_rep)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation85: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x575 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x576 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x577 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x578 => ((x578 = 0%F) \/ (x578 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x579 => ((x579 = 0%F) \/ (x579 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x580 => ((x580 = 0%F) \/ (x580 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x581 => ((x581 = 0%F) \/ (x581 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x582,x583,x584) => (x582 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x582,x583,x584) => (x583 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x582,x583,x584) => (x584 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x582,x583,x584) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x585 => ((x585 = 0%F) \/ (x585 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x586 => ((x586 = 0%F) \/ (x586 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((v = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) /\ (v = max_rep_check)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation86_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x587 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x588 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x589 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x590 => ((x590 = 0%F) \/ (x590 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x591 => ((x591 = 0%F) \/ (x591 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x592 => ((x592 = 0%F) \/ (x592 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x593 => ((x593 = 0%F) \/ (x593 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x594,x595,x596) => (x594 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x594,x595,x596) => (x595 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x594,x595,x596) => (x596 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x594,x595,x596) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x597 => ((x597 = 0%F) \/ (x597 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x598 => ((x598 = 0%F) \/ (x598 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> True -> ((v = (data!0%nat)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation87_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x599 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x600 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x601 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x602 => ((x602 = 0%F) \/ (x602 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x603 => ((x603 = 0%F) \/ (x603 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x604 => ((x604 = 0%F) \/ (x604 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x605 => ((x605 = 0%F) \/ (x605 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x606,x607,x608) => (x606 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x606,x607,x608) => (x607 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x606,x607,x608) => (x608 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x606,x607,x608) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x609 => ((x609 = 0%F) \/ (x609 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x610 => ((x610 = 0%F) \/ (x610 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> True -> ((v = (data!1%nat)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation88_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x611 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x612 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x613 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x614 => ((x614 = 0%F) \/ (x614 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x615 => ((x615 = 0%F) \/ (x615 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x616 => ((x616 = 0%F) \/ (x616 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x617 => ((x617 = 0%F) \/ (x617 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x618,x619,x620) => (x618 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x618,x619,x620) => (x619 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x618,x619,x620) => (x620 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x618,x619,x620) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x621 => ((x621 = 0%F) \/ (x621 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x622 => ((x622 = 0%F) \/ (x622 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> True -> ((v = prove_zero_rep) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation89: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x623 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x624 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x625 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x626 => ((x626 = 0%F) \/ (x626 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x627 => ((x627 = 0%F) \/ (x627 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x628 => ((x628 = 0%F) \/ (x628 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x629 => ((x629 = 0%F) \/ (x629 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x630,x631,x632) => (x630 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x630,x631,x632) => (x631 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x630,x631,x632) => (x632 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x630,x631,x632) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x633 => ((x633 = 0%F) \/ (x633 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x634 => ((x634 = 0%F) \/ (x634 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> (prove_zero_rep = 0%F)) /\ ((v = 0%F) -> ~(prove_zero_rep = 0%F)))) /\ (v = if_not_prove_zero_rep)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation90: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x635 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x636 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x637 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x638 => ((x638 = 0%F) \/ (x638 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x639 => ((x639 = 0%F) \/ (x639 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x640 => ((x640 = 0%F) \/ (x640 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x641 => ((x641 = 0%F) \/ (x641 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x642,x643,x644) => (x642 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x642,x643,x644) => (x643 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x642,x643,x644) => (x644 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x642,x643,x644) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x645 => ((x645 = 0%F) \/ (x645 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x646 => ((x646 = 0%F) \/ (x646 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((v = 0%F) -> ~((data!0%nat) = (data!1%nat))))) /\ (v = zero_rep_check)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation91_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x647 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x648 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x649 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x650 => ((x650 = 0%F) \/ (x650 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x651 => ((x651 = 0%F) \/ (x651 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x652 => ((x652 = 0%F) \/ (x652 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x653 => ((x653 = 0%F) \/ (x653 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x654,x655,x656) => (x654 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x654,x655,x656) => (x655 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x654,x655,x656) => (x656 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x654,x655,x656) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x657 => ((x657 = 0%F) \/ (x657 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x658 => ((x658 = 0%F) \/ (x658 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> True -> ((v = prove_graffiti) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation92: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : Z), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x659 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x660 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x661 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x662 => ((x662 = 0%F) \/ (x662 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x663 => ((x663 = 0%F) \/ (x663 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x664 => ((x664 = 0%F) \/ (x664 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x665 => ((x665 = 0%F) \/ (x665 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x666,x667,x668) => (x666 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x666,x667,x668) => (x667 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x666,x667,x668) => (x668 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x666,x667,x668) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x669 => ((x669 = 0%F) \/ (x669 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x670 => ((x670 = 0%F) \/ (x670 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> True -> ((((0%nat <= v) /\ ((v <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z))) /\ (v = REPL_NONCE_BITS)) -> ((0%nat <= v) /\ ((v <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation93_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x671 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x672 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x673 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x674 => ((x674 = 0%F) \/ (x674 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x675 => ((x675 = 0%F) \/ (x675 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x676 => ((x676 = 0%F) \/ (x676 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x677 => ((x677 = 0%F) \/ (x677 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x678,x679,x680) => (x678 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x678,x679,x680) => (x679 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x678,x679,x680) => (x680 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x678,x679,x680) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x681 => ((x681 = 0%F) \/ (x681 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x682 => ((x682 = 0%F) \/ (x682 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> True -> ((v = graffiti) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation94_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x683 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x684 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x685 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x686 => ((x686 = 0%F) \/ (x686 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x687 => ((x687 = 0%F) \/ (x687 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x688 => ((x688 = 0%F) \/ (x688 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x689 => ((x689 = 0%F) \/ (x689 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x690,x691,x692) => (x690 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x690,x691,x692) => (x691 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x690,x691,x692) => (x692 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x690,x691,x692) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x693 => ((x693 = 0%F) \/ (x693 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x694 => ((x694 = 0%F) \/ (x694 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> True -> ((v = (data!SUM_FIELD_COUNT)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation95_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x695 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x696 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x697 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x698 => ((x698 = 0%F) \/ (x698 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x699 => ((x699 = 0%F) \/ (x699 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x700 => ((x700 = 0%F) \/ (x700 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x701 => ((x701 = 0%F) \/ (x701 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x702,x703,x704) => (x702 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x702,x703,x704) => (x703 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x702,x703,x704) => (x704 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x702,x703,x704) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x705 => ((x705 = 0%F) \/ (x705 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x706 => ((x706 = 0%F) \/ (x706 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> Forall (fun x707 => True) v -> True -> ((v = nil) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation96_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x708 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x709 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x710 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x711 => ((x711 = 0%F) \/ (x711 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x712 => ((x712 = 0%F) \/ (x712 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x713 => ((x713 = 0%F) \/ (x713 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x714 => ((x714 = 0%F) \/ (x714 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x715,x716,x717) => (x715 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x715,x716,x717) => (x716 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x715,x716,x717) => (x717 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x715,x716,x717) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x718 => ((x718 = 0%F) \/ (x718 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x719 => ((x719 = 0%F) \/ (x719 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation97_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x720 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x721 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x722 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x723 => ((x723 = 0%F) \/ (x723 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x724 => ((x724 = 0%F) \/ (x724 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x725 => ((x725 = 0%F) \/ (x725 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x726 => ((x726 = 0%F) \/ (x726 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x727,x728,x729) => (x727 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x727,x728,x729) => (x728 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x727,x728,x729) => (x729 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x727,x728,x729) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x730 => ((x730 = 0%F) \/ (x730 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x731 => ((x731 = 0%F) \/ (x731 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> Forall (fun x732 => True) v -> True -> ((v = ((data!SUM_FIELD_COUNT) :: nil)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation98_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x733 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x734 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x735 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x736 => ((x736 = 0%F) \/ (x736 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x737 => ((x737 = 0%F) \/ (x737 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x738 => ((x738 = 0%F) \/ (x738 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x739 => ((x739 = 0%F) \/ (x739 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x740,x741,x742) => (x740 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x740,x741,x742) => (x741 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x740,x741,x742) => (x742 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x740,x741,x742) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x743 => ((x743 = 0%F) \/ (x743 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x744 => ((x744 = 0%F) \/ (x744 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation99: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x745 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x746 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x747 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x748 => ((x748 = 0%F) \/ (x748 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x749 => ((x749 = 0%F) \/ (x749 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x750 => ((x750 = 0%F) \/ (x750 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x751 => ((x751 = 0%F) \/ (x751 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x752,x753,x754) => (x752 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x752,x753,x754) => (x753 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x752,x753,x754) => (x754 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x752,x753,x754) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x755 => ((x755 = 0%F) \/ (x755 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x756 => ((x756 = 0%F) \/ (x756 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> Forall (fun x757 => True) v -> True -> ((v = (graffiti :: ((data!SUM_FIELD_COUNT) :: nil))) -> ((length v) = 2%nat)).
Proof. hammer. Qed.

Lemma ProveReputation_obligation100_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x758 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x759 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x760 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x761 => ((x761 = 0%F) \/ (x761 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x762 => ((x762 = 0%F) \/ (x762 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x763 => ((x763 = 0%F) \/ (x763 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x764 => ((x764 = 0%F) \/ (x764 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x765,x766,x767) => (x765 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x765,x766,x767) => (x766 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x765,x766,x767) => (x767 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x765,x766,x767) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x768 => ((x768 = 0%F) \/ (x768 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x769 => ((x769 = 0%F) \/ (x769 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation101: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x770 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x771 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x772 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x773 => ((x773 = 0%F) \/ (x773 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x774 => ((x774 = 0%F) \/ (x774 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x775 => ((x775 = 0%F) \/ (x775 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x776 => ((x776 = 0%F) \/ (x776 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x777,x778,x779) => (x777 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x777,x778,x779) => (x778 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x777,x778,x779) => (x779 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x777,x778,x779) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x780 => ((x780 = 0%F) \/ (x780 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x781 => ((x781 = 0%F) \/ (x781 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> (prove_graffiti = 0%F)) /\ ((v = 0%F) -> ~(prove_graffiti = 0%F)))) /\ (v = if_not_check_graffiti)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation102: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x782 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x783 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x784 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x785 => ((x785 = 0%F) \/ (x785 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x786 => ((x786 = 0%F) \/ (x786 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x787 => ((x787 = 0%F) \/ (x787 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x788 => ((x788 = 0%F) \/ (x788 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x789,x790,x791) => (x789 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x789,x790,x791) => (x790 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x789,x790,x791) => (x791 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x789,x790,x791) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x792 => ((x792 = 0%F) \/ (x792 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x793 => ((x793 = 0%F) \/ (x793 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> True -> (((((v = 0%F) \/ (v = 1%F)) /\ (((v = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((v = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) /\ (v = repl_field_equal)) -> ((v = 0%F) \/ (v = 1%F))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation103: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x794 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x795 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x796 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x797 => ((x797 = 0%F) \/ (x797 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x798 => ((x798 = 0%F) \/ (x798 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x799 => ((x799 = 0%F) \/ (x799 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x800 => ((x800 = 0%F) \/ (x800 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x801,x802,x803) => (x801 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x801,x802,x803) => (x802 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x801,x802,x803) => (x803 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x801,x802,x803) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x804 => ((x804 = 0%F) \/ (x804 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x805 => ((x805 = 0%F) \/ (x805 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> True -> (((v = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) /\ (v = epoch_key)) -> (v = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil))))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation104: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x806 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x807 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x808 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x809 => ((x809 = 0%F) \/ (x809 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x810 => ((x810 = 0%F) \/ (x810 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x811 => ((x811 = 0%F) \/ (x811 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x812 => ((x812 = 0%F) \/ (x812 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x813,x814,x815) => (x813 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x813,x814,x815) => (x814 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x813,x814,x815) => (x815 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x813,x814,x815) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x816 => ((x816 = 0%F) \/ (x816 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x817 => ((x817 = 0%F) \/ (x817 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> True -> (((v = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) /\ (v = state_tree_root)) -> (v = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation105_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x818 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x819 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x820 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x821 => ((x821 = 0%F) \/ (x821 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x822 => ((x822 = 0%F) \/ (x822 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x823 => ((x823 = 0%F) \/ (x823 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x824 => ((x824 = 0%F) \/ (x824 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x825,x826,x827) => (x825 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x825,x826,x827) => (x826 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x825,x826,x827) => (x827 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x825,x826,x827) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x828 => ((x828 = 0%F) \/ (x828 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x829 => ((x829 = 0%F) \/ (x829 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> True -> (((v = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) /\ (v = control_0)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation106_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x830 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x831 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x832 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x833 => ((x833 = 0%F) \/ (x833 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x834 => ((x834 = 0%F) \/ (x834 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x835 => ((x835 = 0%F) \/ (x835 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x836 => ((x836 = 0%F) \/ (x836 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x837,x838,x839) => (x837 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x837,x838,x839) => (x838 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x837,x838,x839) => (x839 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x837,x838,x839) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x840 => ((x840 = 0%F) \/ (x840 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x841 => ((x841 = 0%F) \/ (x841 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> True -> (((v = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) /\ (v = control_1)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation107_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x842 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x843 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x844 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x845 => ((x845 = 0%F) \/ (x845 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x846 => ((x846 = 0%F) \/ (x846 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x847 => ((x847 = 0%F) \/ (x847 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x848 => ((x848 = 0%F) \/ (x848 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x849,x850,x851) => (x849 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x849,x850,x851) => (x850 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x849,x850,x851) => (x851 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x849,x850,x851) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x852 => ((x852 = 0%F) \/ (x852 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x853 => ((x853 = 0%F) \/ (x853 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> Forall (fun x854 => True) v -> True -> ((v = nil) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation108_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x855 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x856 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x857 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x858 => ((x858 = 0%F) \/ (x858 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x859 => ((x859 = 0%F) \/ (x859 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x860 => ((x860 = 0%F) \/ (x860 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x861 => ((x861 = 0%F) \/ (x861 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x862,x863,x864) => (x862 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x862,x863,x864) => (x863 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x862,x863,x864) => (x864 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x862,x863,x864) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x865 => ((x865 = 0%F) \/ (x865 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x866 => ((x866 = 0%F) \/ (x866 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation109_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x867 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x868 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x869 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x870 => ((x870 = 0%F) \/ (x870 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x871 => ((x871 = 0%F) \/ (x871 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x872 => ((x872 = 0%F) \/ (x872 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x873 => ((x873 = 0%F) \/ (x873 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x874,x875,x876) => (x874 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x874,x875,x876) => (x875 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x874,x875,x876) => (x876 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x874,x875,x876) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x877 => ((x877 = 0%F) \/ (x877 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x878 => ((x878 = 0%F) \/ (x878 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> Forall (fun x879 => True) v -> True -> ((v = (control_1 :: nil)) -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation110_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x880 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x881 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x882 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x883 => ((x883 = 0%F) \/ (x883 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x884 => ((x884 = 0%F) \/ (x884 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x885 => ((x885 = 0%F) \/ (x885 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x886 => ((x886 = 0%F) \/ (x886 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x887,x888,x889) => (x887 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x887,x888,x889) => (x888 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x887,x888,x889) => (x889 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x887,x888,x889) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x890 => ((x890 = 0%F) \/ (x890 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x891 => ((x891 = 0%F) \/ (x891 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma ProveReputation_obligation111: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : (list F)), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x892 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x893 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x894 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x895 => ((x895 = 0%F) \/ (x895 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x896 => ((x896 = 0%F) \/ (x896 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x897 => ((x897 = 0%F) \/ (x897 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x898 => ((x898 = 0%F) \/ (x898 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x899,x900,x901) => (x899 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x899,x900,x901) => (x900 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x899,x900,x901) => (x901 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x899,x900,x901) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x902 => ((x902 = 0%F) \/ (x902 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x903 => ((x903 = 0%F) \/ (x903 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> Forall (fun x904 => True) v -> True -> ((v = (control_0 :: (control_1 :: nil))) -> ((((v!0%nat) = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) /\ (((v!1%nat) = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) /\ True)) /\ ((length v) = 2%nat))).
Proof. hammer. Qed.

Lemma ProveReputation_obligation112_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit) (v : F), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x905 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x906 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x907 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x908 => ((x908 = 0%F) \/ (x908 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x909 => ((x909 = 0%F) \/ (x909 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x910 => ((x910 = 0%F) \/ (x910 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x911 => ((x911 = 0%F) \/ (x911 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x912,x913,x914) => (x912 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x912,x913,x914) => (x913 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x912,x913,x914) => (x914 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x912,x913,x914) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x915 => ((x915 = 0%F) \/ (x915 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x916 => ((x916 = 0%F) \/ (x916 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> True -> (True -> True).
Proof. auto. Qed.

Lemma ProveReputation_obligation113: forall (STATE_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (SUM_FIELD_COUNT : nat) (FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (data : (list F)) (prove_graffiti : F) (graffiti : F) (reveal_nonce : F) (attester_id : F) (epoch : F) (nonce : F) (min_rep : F) (max_rep : F) (prove_min_rep : F) (prove_max_rep : F) (prove_zero_rep : F) (sig_data : F) (min_rep_bits : (list F)) (max_rep_bits : (list F)) (u0 : unit) (u1 : unit) (u2 : unit) (u3 : unit) (control_1 : F) (epoch_range_check : (list F)) (attester_id_check : (list F)) (epoch_key_gen : (F * F * F)) (epoch_key : F) (state_tree_root : F) (control_0 : F) (data_0_check : (list F)) (data_1_check : (list F)) (min_rep_check : F) (if_not_prove_min_rep : F) (output_rep_check : F) (u4 : unit) (max_rep_check : F) (if_not_prove_max_rep : F) (max_rep_check_out : F) (u5 : unit) (zero_rep_check : F) (if_not_prove_zero_rep : F) (zero_rep_check_out : F) (u6 : unit) (if_not_check_graffiti : F) (repl_field_equal : F) (check_graffiti : F) (u7 : unit), ((STATE_TREE_DEPTH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> ((EPOCH_KEY_NONCE_PER_EPOCH <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> (SUM_FIELD_COUNT < FIELD_COUNT) -> ((REPL_NONCE_BITS <= 254%nat) /\ (254%nat <= (C.k - 1%nat)%Z)) -> True -> Forall (fun x917 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x918 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x919 => True) data -> ((length data) = FIELD_COUNT) -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> True -> Forall (fun x920 => ((x920 = 0%F) \/ (x920 = 1%F))) min_rep_bits -> (((as_le_f min_rep_bits) = min_rep) /\ ((length min_rep_bits) = 64%nat)) -> Forall (fun x921 => ((x921 = 0%F) \/ (x921 = 1%F))) max_rep_bits -> (((as_le_f max_rep_bits) = max_rep) /\ ((length max_rep_bits) = 64%nat)) -> ((prove_graffiti * (prove_graffiti - 1%F)%F)%F = 0%F) -> ((prove_min_rep * (prove_min_rep - 1%F)%F)%F = 0%F) -> ((prove_max_rep * (prove_max_rep - 1%F)%F)%F = 0%F) -> ((prove_zero_rep * (prove_zero_rep - 1%F)%F)%F = 0%F) -> (control_1 = ((prove_graffiti * (2%F ^ 131%nat)%F)%F + ((prove_zero_rep * (2%F ^ 130%nat)%F)%F + ((prove_max_rep * (2%F ^ 129%nat)%F)%F + ((prove_min_rep * (2%F ^ 128%nat)%F)%F + ((max_rep * (2%F ^ 64%nat)%F)%F + min_rep)%F)%F)%F)%F)%F) -> Forall (fun x922 => ((x922 = 0%F) \/ (x922 = 1%F))) epoch_range_check -> (((as_le_f epoch_range_check) = epoch) /\ ((length epoch_range_check) = 48%nat)) -> Forall (fun x923 => ((x923 = 0%F) \/ (x923 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> match epoch_key_gen with (x924,x925,x926) => (x924 = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) end -> match epoch_key_gen with (x924,x925,x926) => (x925 = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) end -> match epoch_key_gen with (x924,x925,x926) => (x926 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) end -> match epoch_key_gen with (x924,x925,x926) => True end -> (epoch_key = (Poseidon 2%nat (identity_secret :: ((attester_id + (((2%F ^ 160%nat)%F * epoch)%F + ((2%F ^ 208%nat)%F * nonce)%F)%F)%F :: nil)))) -> (state_tree_root = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil)))))) -> (control_0 = ((reveal_nonce * (2%F ^ 232%nat)%F)%F + ((attester_id * (2%F ^ 72%nat)%F)%F + ((epoch * (2%F ^ 8%nat)%F)%F + (reveal_nonce * nonce)%F)%F)%F)%F) -> Forall (fun x927 => ((x927 = 0%F) \/ (x927 = 1%F))) data_0_check -> (((as_le_f data_0_check) = (data!0%nat)) /\ ((length data_0_check) = 64%nat)) -> Forall (fun x928 => ((x928 = 0%F) \/ (x928 = 1%F))) data_1_check -> (((as_le_f data_1_check) = (data!1%nat)) /\ ((length data_1_check) = 64%nat)) -> (((min_rep_check = 0%F) \/ (min_rep_check = 1%F)) /\ (((min_rep_check = 1%F) -> ((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))) /\ ((min_rep_check = 0%F) -> ~((^ ((data!1%nat) + min_rep)%F) <= (^ (data!0%nat)))))) -> (((if_not_prove_min_rep = 0%F) \/ (if_not_prove_min_rep = 1%F)) /\ (((if_not_prove_min_rep = 1%F) -> (prove_min_rep = 0%F)) /\ ((if_not_prove_min_rep = 0%F) -> ~(prove_min_rep = 0%F)))) -> (((output_rep_check = 0%F) \/ (output_rep_check = 1%F)) /\ (((output_rep_check = 1%F) -> (f_or if_not_prove_min_rep min_rep_check)) /\ ((output_rep_check = 0%F) -> ~(f_or if_not_prove_min_rep min_rep_check)))) -> (output_rep_check = 1%F) -> (((max_rep_check = 0%F) \/ (max_rep_check = 1%F)) /\ (((max_rep_check = 1%F) -> ((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))) /\ ((max_rep_check = 0%F) -> ~((^ ((data!0%nat) + max_rep)%F) <= (^ (data!1%nat)))))) -> (((if_not_prove_max_rep = 0%F) \/ (if_not_prove_max_rep = 1%F)) /\ (((if_not_prove_max_rep = 1%F) -> (prove_max_rep = 0%F)) /\ ((if_not_prove_max_rep = 0%F) -> ~(prove_max_rep = 0%F)))) -> (((max_rep_check_out = 0%F) \/ (max_rep_check_out = 1%F)) /\ (((max_rep_check_out = 1%F) -> (f_or if_not_prove_max_rep max_rep_check)) /\ ((max_rep_check_out = 0%F) -> ~(f_or if_not_prove_max_rep max_rep_check)))) -> (max_rep_check_out = 1%F) -> (((zero_rep_check = 0%F) \/ (zero_rep_check = 1%F)) /\ (((zero_rep_check = 1%F) -> ((data!0%nat) = (data!1%nat))) /\ ((zero_rep_check = 0%F) -> ~((data!0%nat) = (data!1%nat))))) -> (((if_not_prove_zero_rep = 0%F) \/ (if_not_prove_zero_rep = 1%F)) /\ (((if_not_prove_zero_rep = 1%F) -> (prove_zero_rep = 0%F)) /\ ((if_not_prove_zero_rep = 0%F) -> ~(prove_zero_rep = 0%F)))) -> (((zero_rep_check_out = 0%F) \/ (zero_rep_check_out = 1%F)) /\ (((zero_rep_check_out = 1%F) -> (f_or if_not_prove_zero_rep zero_rep_check)) /\ ((zero_rep_check_out = 0%F) -> ~(f_or if_not_prove_zero_rep zero_rep_check)))) -> (zero_rep_check_out = 1%F) -> (((if_not_check_graffiti = 0%F) \/ (if_not_check_graffiti = 1%F)) /\ (((if_not_check_graffiti = 1%F) -> (prove_graffiti = 0%F)) /\ ((if_not_check_graffiti = 0%F) -> ~(prove_graffiti = 0%F)))) -> (((repl_field_equal = 0%F) \/ (repl_field_equal = 1%F)) /\ (((repl_field_equal = 1%F) -> (((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)) /\ ((repl_field_equal = 0%F) -> ~(((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!0%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z = ((^ ((graffiti :: ((data!SUM_FIELD_COUNT) :: nil))!1%nat)) mod (2%nat ^ (254%nat - REPL_NONCE_BITS)%nat)%Z)%Z)))) -> (((check_graffiti = 0%F) \/ (check_graffiti = 1%F)) /\ (((check_graffiti = 1%F) -> (f_or if_not_check_graffiti repl_field_equal)) /\ ((check_graffiti = 0%F) -> ~(f_or if_not_check_graffiti repl_field_equal)))) -> (check_graffiti = 1%F) -> (True -> (((prove_graffiti = 0%F) \/ (prove_graffiti = 1%F)) /\ (((prove_min_rep = 0%F) \/ (prove_min_rep = 1%F)) /\ (((prove_max_rep = 0%F) \/ (prove_max_rep = 1%F)) /\ (((prove_zero_rep = 0%F) \/ (prove_zero_rep = 1%F)) /\ (((^ min_rep) < (2%nat ^ 64%nat)%Z) /\ (((^ max_rep) < (2%nat ^ 64%nat)%Z) /\ (((^ epoch) < (2%nat ^ 48%nat)%Z) /\ (((^ attester_id) < (2%nat ^ 160%nat)%Z) /\ True))))))))).
Proof.
intros. subst.
clear H59. clear H55 H54 H51 H52 H50 H58 H48 H56 H60 H47 H46.
pose proof (as_le_f_lt min_rep_bits).
pose proof (as_le_f_lt max_rep_bits).
pose proof (as_le_f_lt epoch_range_check).
pose proof (as_le_f_lt attester_id_check).
intuition;try apply binary_proof;auto;subst.
- rewrite H48 in *;lia.
- rewrite H49 in *;lia.
- rewrite H50 in *;lia.
- rewrite H51 in *;lia. 
Qed.