(** * DSL benchmark: Unirep *)

Require Import Coq.Lists.List.
Require Import Coq.micromega.Lia.
Require Import Coq.Init.Peano.
Require Import Coq.Arith.PeanoNat.
Require Import Coq.Arith.Compare_dec.
Require Import Coq.PArith.BinPosDef.
Require Import Coq.ZArith.BinInt Coq.ZArith.ZArith Coq.ZArith.Zdiv Coq.ZArith.Znumtheory Coq.NArith.NArith. (* import Zdiv before Znumtheory *)
Require Import Coq.NArith.Nnat.

Require Import Crypto.Spec.ModularArithmetic.
Require Import Crypto.Arithmetic.PrimeFieldTheorems Crypto.Algebra.Field.
Require Import Crypto.Util.Decidable. (* Crypto.Util.Notations. *)
Require Import Coq.setoid_ring.Ring_theory Coq.setoid_ring.Field_theory Coq.setoid_ring.Field_tac.

From Circom Require Import Circom Util Default Tuple ListUtil LibTactics Simplify Repr Coda.
From Circom.CircomLib Require Import Bitify.

Local Coercion N.of_nat : nat >-> N.
Local Coercion Z.of_nat : nat >-> Z.

Local Open Scope list_scope.
Local Open Scope F_scope.
Local Open Scope Z_scope.
Local Open Scope circom_scope.
Local Open Scope tuple_scope.

Definition Poseidon (nInputs : nat) (inputs : list F) : F. Admitted.

Axiom Poseidon_2 : forall inputs : list F,
  length inputs = 2%nat ->
  Poseidon 2%nat inputs = Poseidon 2%nat ((inputs!0%nat)::(inputs!1%nat)::nil).


#[global]Hint Extern 10 (Forall _ (firstn _ _)) => apply Forall_firstn: core.
#[global]Hint Extern 10  => match goal with
   | [ |- context[List_nth_Default _ _] ] => unfold_default end: core.
   #[global]Hint Extern 10  => match goal with
   | [ |- context[List.nth  _ _ _] ] => apply Forall_nth end: core.
#[global]Hint Extern 10 => match goal with
  [ |- context[length _] ] => rewrite_length end: core.
#[global]Hint Extern 10 (Forall _ (skipn _ _)) => apply Forall_skipn: core.

#[global]Hint Extern 10 (Forall _ (_ :: _)) => constructor: core.
#[global]Hint Extern 10 (Z.of_N (N.of_nat _)) => rewrite nat_N_Z: core.
#[global]Hint Extern 10  => repeat match goal with
  [ H: context[Z.of_N (N.of_nat _)] |- _] => rewrite nat_N_Z in H end: core.

#[global]Hint Extern 10 (_ < _) => lia: core.
#[global]Hint Extern 10 (_ < _)%nat => lia: core.
#[global]Hint Extern 10 (_ <= _) => lia: core.
#[global]Hint Extern 10 (_ <= _)%nat => lia: core.
#[global]Hint Extern 10 (_ > _) => lia: core.
#[global]Hint Extern 10 (_ > _)%nat => lia: core.
#[global]Hint Extern 10 (_ >= _) => lia: core.
#[global]Hint Extern 10 (_ >= _)%nat => lia: core.
#[global]Hint Extern 10 (S _ = S _) => f_equal: core.

Definition zip {A B} (xs : list A) (ys : list B) := combine xs ys.

(* Note: This is a placeholder implementation that lets us prove many
trivial and even some nontrivial MerkleTreeInclusionProof obligations *)
Definition MrklTreeInclPfHash (xs : list (F * F)) (init : F) := 
  fold_left (fun (y:F) (x:(F*F)) => if dec (fst x = 0%F) then (Poseidon 2%nat (y :: (snd x) :: nil)) else (Poseidon 2%nat ((snd x):: y :: nil))) 
                       xs init.

Definition u_state_tree_leaf (a:list F) (b:F) := fold_left (fun (x:F) (y:F) => Poseidon 2%nat (x::y::nil)) a b.

Axiom k_rng: k > 100.

Lemma UserStateTransition_obligation0: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (v : Z), True -> True -> True -> Forall (fun x0 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x1 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x2 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x3 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x4 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x6 => Forall (fun x5 => True) x6) new_data -> Forall (fun x6 => ((length x6) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x8 => Forall (fun x7 => True) x8) epoch_tree_elements -> Forall (fun x8 => ((length x8) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x10 => Forall (fun x9 => True) x10) epoch_tree_indices -> Forall (fun x10 => ((length x10) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> ((v = 48%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation1_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (v : F), True -> True -> True -> Forall (fun x11 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x12 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x13 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x14 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x15 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x17 => Forall (fun x16 => True) x17) new_data -> Forall (fun x17 => ((length x17) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x19 => Forall (fun x18 => True) x19) epoch_tree_elements -> Forall (fun x19 => ((length x19) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x21 => Forall (fun x20 => True) x21) epoch_tree_indices -> Forall (fun x21 => ((length x21) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> ((v = from_epoch) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation2: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (v : Z), True -> True -> True -> Forall (fun x22 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x23 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x24 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x25 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x26 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x28 => Forall (fun x27 => True) x28) new_data -> Forall (fun x28 => ((length x28) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x30 => Forall (fun x29 => True) x30) epoch_tree_elements -> Forall (fun x30 => ((length x30) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x32 => Forall (fun x31 => True) x32) epoch_tree_indices -> Forall (fun x32 => ((length x32) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x33 => ((x33 = 0%F) \/ (x33 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> True -> ((v = 48%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation3_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (v : F), True -> True -> True -> Forall (fun x34 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x35 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x36 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x37 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x38 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x40 => Forall (fun x39 => True) x40) new_data -> Forall (fun x40 => ((length x40) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x42 => Forall (fun x41 => True) x42) epoch_tree_elements -> Forall (fun x42 => ((length x42) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x44 => Forall (fun x43 => True) x44) epoch_tree_indices -> Forall (fun x44 => ((length x44) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x45 => ((x45 = 0%F) \/ (x45 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> True -> ((v = to_epoch) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation4: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (v : Z), True -> True -> True -> Forall (fun x46 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x47 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x48 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x49 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x50 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x52 => Forall (fun x51 => True) x52) new_data -> Forall (fun x52 => ((length x52) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x54 => Forall (fun x53 => True) x54) epoch_tree_elements -> Forall (fun x54 => ((length x54) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x56 => Forall (fun x55 => True) x56) epoch_tree_indices -> Forall (fun x56 => ((length x56) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x57 => ((x57 = 0%F) \/ (x57 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x58 => ((x58 = 0%F) \/ (x58 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> True -> ((v = 48%nat) -> ((0%nat <= v) /\ (v <= (C.k - 1%nat)%Z))).
Proof.
intros. unwrap_C. pose proof k_rng.
hammer. Qed.

Lemma UserStateTransition_obligation5: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (v : F), True -> True -> True -> Forall (fun x59 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x60 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x61 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x62 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x63 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x65 => Forall (fun x64 => True) x65) new_data -> Forall (fun x65 => ((length x65) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x67 => Forall (fun x66 => True) x67) epoch_tree_elements -> Forall (fun x67 => ((length x67) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x69 => Forall (fun x68 => True) x69) epoch_tree_indices -> Forall (fun x69 => ((length x69) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x70 => ((x70 = 0%F) \/ (x70 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x71 => ((x71 = 0%F) \/ (x71 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> True -> ((v = to_epoch) -> ((^ v) <= ((2%nat ^ 48%nat)%Z - 1%nat)%Z)).
Proof.
intros. intuition.
pose proof (as_le_f_lt to_epoch_check). 
subst. rewrite H31 in *. 
hammer.
Qed.

Lemma UserStateTransition_obligation6: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (v : F), True -> True -> True -> Forall (fun x72 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x73 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x74 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x75 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x76 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x78 => Forall (fun x77 => True) x78) new_data -> Forall (fun x78 => ((length x78) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x80 => Forall (fun x79 => True) x80) epoch_tree_elements -> Forall (fun x80 => ((length x80) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x82 => Forall (fun x81 => True) x82) epoch_tree_indices -> Forall (fun x82 => ((length x82) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x83 => ((x83 = 0%F) \/ (x83 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x84 => ((x84 = 0%F) \/ (x84 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> True -> ((v = from_epoch) -> ((^ v) <= ((2%nat ^ 48%nat)%Z - 1%nat)%Z)).
Proof. 
intros. intuition.
pose proof (as_le_f_lt from_epoch_check). 
subst. rewrite H30 in *. 
hammer.
Qed.

Lemma UserStateTransition_obligation7: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (v : Z), True -> True -> True -> Forall (fun x85 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x86 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x87 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x88 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x89 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x91 => Forall (fun x90 => True) x91) new_data -> Forall (fun x91 => ((length x91) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x93 => Forall (fun x92 => True) x93) epoch_tree_elements -> Forall (fun x93 => ((length x93) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x95 => Forall (fun x94 => True) x95) epoch_tree_indices -> Forall (fun x95 => ((length x95) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x96 => ((x96 = 0%F) \/ (x96 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x97 => ((x97 = 0%F) \/ (x97 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> True -> ((v = 160%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation8_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (v : F), True -> True -> True -> Forall (fun x98 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x99 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x100 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x101 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x102 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x104 => Forall (fun x103 => True) x104) new_data -> Forall (fun x104 => ((length x104) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x106 => Forall (fun x105 => True) x106) epoch_tree_elements -> Forall (fun x106 => ((length x106) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x108 => Forall (fun x107 => True) x108) epoch_tree_indices -> Forall (fun x108 => ((length x108) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x109 => ((x109 = 0%F) \/ (x109 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x110 => ((x110 = 0%F) \/ (x110 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> True -> ((v = attester_id) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation9: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (v : Z), True -> True -> True -> Forall (fun x111 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x112 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x113 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x114 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x115 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x117 => Forall (fun x116 => True) x117) new_data -> Forall (fun x117 => ((length x117) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x119 => Forall (fun x118 => True) x119) epoch_tree_elements -> Forall (fun x119 => ((length x119) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x121 => Forall (fun x120 => True) x121) epoch_tree_indices -> Forall (fun x121 => ((length x121) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x122 => ((x122 = 0%F) \/ (x122 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x123 => ((x123 = 0%F) \/ (x123 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x124 => ((x124 = 0%F) \/ (x124 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> (((0%nat <= v) /\ (v = FIELD_COUNT)) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation10: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (v : (list F)), True -> True -> True -> Forall (fun x125 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x126 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x127 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x128 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x129 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x131 => Forall (fun x130 => True) x131) new_data -> Forall (fun x131 => ((length x131) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x133 => Forall (fun x132 => True) x133) epoch_tree_elements -> Forall (fun x133 => ((length x133) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x135 => Forall (fun x134 => True) x135) epoch_tree_indices -> Forall (fun x135 => ((length x135) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x136 => ((x136 = 0%F) \/ (x136 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x137 => ((x137 = 0%F) \/ (x137 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x138 => ((x138 = 0%F) \/ (x138 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> Forall (fun x139 => True) v -> True -> ((((length v) = FIELD_COUNT) /\ (v = data)) -> ((length v) = FIELD_COUNT)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation11_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (v : F), True -> True -> True -> Forall (fun x140 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x141 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x142 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x143 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x144 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x146 => Forall (fun x145 => True) x146) new_data -> Forall (fun x146 => ((length x146) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x148 => Forall (fun x147 => True) x148) epoch_tree_elements -> Forall (fun x148 => ((length x148) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x150 => Forall (fun x149 => True) x150) epoch_tree_indices -> Forall (fun x150 => ((length x150) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x151 => ((x151 = 0%F) \/ (x151 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x152 => ((x152 = 0%F) \/ (x152 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x153 => ((x153 = 0%F) \/ (x153 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = identity_secret) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation12_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (v : F), True -> True -> True -> Forall (fun x154 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x155 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x156 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x157 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x158 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x160 => Forall (fun x159 => True) x160) new_data -> Forall (fun x160 => ((length x160) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x162 => Forall (fun x161 => True) x162) epoch_tree_elements -> Forall (fun x162 => ((length x162) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x164 => Forall (fun x163 => True) x164) epoch_tree_indices -> Forall (fun x164 => ((length x164) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x165 => ((x165 = 0%F) \/ (x165 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x166 => ((x166 = 0%F) \/ (x166 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x167 => ((x167 = 0%F) \/ (x167 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = attester_id) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation13_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (v : F), True -> True -> True -> Forall (fun x168 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x169 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x170 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x171 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x172 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x174 => Forall (fun x173 => True) x174) new_data -> Forall (fun x174 => ((length x174) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x176 => Forall (fun x175 => True) x176) epoch_tree_elements -> Forall (fun x176 => ((length x176) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x178 => Forall (fun x177 => True) x178) epoch_tree_indices -> Forall (fun x178 => ((length x178) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x179 => ((x179 = 0%F) \/ (x179 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x180 => ((x180 = 0%F) \/ (x180 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x181 => ((x181 = 0%F) \/ (x181 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> True -> ((v = from_epoch) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation14: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (v : Z), True -> True -> True -> Forall (fun x182 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x183 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x184 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x185 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x186 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x188 => Forall (fun x187 => True) x188) new_data -> Forall (fun x188 => ((length x188) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x190 => Forall (fun x189 => True) x190) epoch_tree_elements -> Forall (fun x190 => ((length x190) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x192 => Forall (fun x191 => True) x192) epoch_tree_indices -> Forall (fun x192 => ((length x192) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x193 => ((x193 = 0%F) \/ (x193 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x194 => ((x194 = 0%F) \/ (x194 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x195 => ((x195 = 0%F) \/ (x195 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> True -> (((0%nat <= v) /\ (v = STATE_TREE_DEPTH)) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation15_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (v : F), True -> True -> True -> Forall (fun x196 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x197 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x198 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x199 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x200 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x202 => Forall (fun x201 => True) x202) new_data -> Forall (fun x202 => ((length x202) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x204 => Forall (fun x203 => True) x204) epoch_tree_elements -> Forall (fun x204 => ((length x204) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x206 => Forall (fun x205 => True) x206) epoch_tree_indices -> Forall (fun x206 => ((length x206) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x207 => ((x207 = 0%F) \/ (x207 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x208 => ((x208 = 0%F) \/ (x208 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x209 => ((x209 = 0%F) \/ (x209 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> True -> (((v = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) /\ (v = leaf_hasher)) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation16: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (v : (list F)), True -> True -> True -> Forall (fun x210 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x211 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x212 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x213 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x214 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x216 => Forall (fun x215 => True) x216) new_data -> Forall (fun x216 => ((length x216) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x218 => Forall (fun x217 => True) x218) epoch_tree_elements -> Forall (fun x218 => ((length x218) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x220 => Forall (fun x219 => True) x220) epoch_tree_indices -> Forall (fun x220 => ((length x220) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x221 => ((x221 = 0%F) \/ (x221 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x222 => ((x222 = 0%F) \/ (x222 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x223 => ((x223 = 0%F) \/ (x223 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> Forall (fun x224 => True) v -> True -> ((((length v) = STATE_TREE_DEPTH) /\ (v = state_tree_indexes)) -> ((length v) = STATE_TREE_DEPTH)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation17: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (v : (list F)), True -> True -> True -> Forall (fun x225 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x226 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x227 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x228 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x229 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x231 => Forall (fun x230 => True) x231) new_data -> Forall (fun x231 => ((length x231) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x233 => Forall (fun x232 => True) x233) epoch_tree_elements -> Forall (fun x233 => ((length x233) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x235 => Forall (fun x234 => True) x235) epoch_tree_indices -> Forall (fun x235 => ((length x235) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x236 => ((x236 = 0%F) \/ (x236 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x237 => ((x237 = 0%F) \/ (x237 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x238 => ((x238 = 0%F) \/ (x238 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> Forall (fun x239 => True) v -> True -> ((((length v) = STATE_TREE_DEPTH) /\ (v = state_tree_elements)) -> ((length v) = STATE_TREE_DEPTH)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation18: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (v : Z), True -> True -> True -> Forall (fun x240 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x241 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x242 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x243 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x244 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x246 => Forall (fun x245 => True) x246) new_data -> Forall (fun x246 => ((length x246) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x248 => Forall (fun x247 => True) x248) epoch_tree_elements -> Forall (fun x248 => ((length x248) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x250 => Forall (fun x249 => True) x250) epoch_tree_indices -> Forall (fun x250 => ((length x250) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x251 => ((x251 = 0%F) \/ (x251 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x252 => ((x252 = 0%F) \/ (x252 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x253 => ((x253 = 0%F) \/ (x253 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> True -> ((v = 2%nat) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation19: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (v : (list F)), True -> True -> True -> Forall (fun x254 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x255 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x256 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x257 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x258 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x260 => Forall (fun x259 => True) x260) new_data -> Forall (fun x260 => ((length x260) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x262 => Forall (fun x261 => True) x262) epoch_tree_elements -> Forall (fun x262 => ((length x262) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x264 => Forall (fun x263 => True) x264) epoch_tree_indices -> Forall (fun x264 => ((length x264) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x265 => ((x265 = 0%F) \/ (x265 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x266 => ((x266 = 0%F) \/ (x266 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x267 => ((x267 = 0%F) \/ (x267 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> Forall (fun x268 => True) v -> True -> ((((True /\ ((v!0%nat) = state_merkletree)) /\ ((v!1%nat) = epoch_tree_root)) /\ ((length v) = 2%nat)) -> ((length v) = 2%nat)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation20: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (v : Z), True -> True -> True -> Forall (fun x269 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x270 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x271 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x272 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x273 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x275 => Forall (fun x274 => True) x275) new_data -> Forall (fun x275 => ((length x275) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x277 => Forall (fun x276 => True) x277) epoch_tree_elements -> Forall (fun x277 => ((length x277) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x279 => Forall (fun x278 => True) x279) epoch_tree_indices -> Forall (fun x279 => ((length x279) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x280 => ((x280 = 0%F) \/ (x280 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x281 => ((x281 = 0%F) \/ (x281 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x282 => ((x282 = 0%F) \/ (x282 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> True -> (((0%nat <= v) /\ (v = HISTORY_TREE_DEPTH)) -> (0%nat <= v)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation21_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (v : F), True -> True -> True -> Forall (fun x283 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x284 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x285 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x286 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x287 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x289 => Forall (fun x288 => True) x289) new_data -> Forall (fun x289 => ((length x289) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x291 => Forall (fun x290 => True) x291) epoch_tree_elements -> Forall (fun x291 => ((length x291) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x293 => Forall (fun x292 => True) x293) epoch_tree_indices -> Forall (fun x293 => ((length x293) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x294 => ((x294 = 0%F) \/ (x294 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x295 => ((x295 = 0%F) \/ (x295 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x296 => ((x296 = 0%F) \/ (x296 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> True -> (((v = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) /\ (v = history_leaf_hasher)) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation22: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (v : (list F)), True -> True -> True -> Forall (fun x297 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x298 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x299 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x300 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x301 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x303 => Forall (fun x302 => True) x303) new_data -> Forall (fun x303 => ((length x303) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x305 => Forall (fun x304 => True) x305) epoch_tree_elements -> Forall (fun x305 => ((length x305) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x307 => Forall (fun x306 => True) x307) epoch_tree_indices -> Forall (fun x307 => ((length x307) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x308 => ((x308 = 0%F) \/ (x308 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x309 => ((x309 = 0%F) \/ (x309 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x310 => ((x310 = 0%F) \/ (x310 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> Forall (fun x311 => True) v -> True -> ((((length v) = HISTORY_TREE_DEPTH) /\ (v = history_tree_indices)) -> ((length v) = HISTORY_TREE_DEPTH)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation23: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (v : (list F)), True -> True -> True -> Forall (fun x312 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x313 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x314 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x315 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x316 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x318 => Forall (fun x317 => True) x318) new_data -> Forall (fun x318 => ((length x318) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x320 => Forall (fun x319 => True) x320) epoch_tree_elements -> Forall (fun x320 => ((length x320) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x322 => Forall (fun x321 => True) x322) epoch_tree_indices -> Forall (fun x322 => ((length x322) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x323 => ((x323 = 0%F) \/ (x323 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x324 => ((x324 = 0%F) \/ (x324 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x325 => ((x325 = 0%F) \/ (x325 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> Forall (fun x326 => True) v -> True -> ((((length v) = HISTORY_TREE_DEPTH) /\ (v = history_tree_elements)) -> ((length v) = HISTORY_TREE_DEPTH)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation24: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : F), True -> True -> True -> Forall (fun x327 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x328 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x329 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x330 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x331 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x333 => Forall (fun x332 => True) x333) new_data -> Forall (fun x333 => ((length x333) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x335 => Forall (fun x334 => True) x335) epoch_tree_elements -> Forall (fun x335 => ((length x335) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x337 => Forall (fun x336 => True) x337) epoch_tree_indices -> Forall (fun x337 => ((length x337) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x338 => ((x338 = 0%F) \/ (x338 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x339 => ((x339 = 0%F) \/ (x339 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x340 => ((x340 = 0%F) \/ (x340 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> True -> ((((v = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) /\ (v = history_merkletree)) -> (v = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) (Poseidon 2%nat ((MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) :: (epoch_tree_root :: nil)))))).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation25_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : F), True -> True -> True -> Forall (fun x341 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x342 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x343 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x344 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x345 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x347 => Forall (fun x346 => True) x347) new_data -> Forall (fun x347 => ((length x347) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x349 => Forall (fun x348 => True) x349) epoch_tree_elements -> Forall (fun x349 => ((length x349) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x351 => Forall (fun x350 => True) x351) epoch_tree_indices -> Forall (fun x351 => ((length x351) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x352 => ((x352 = 0%F) \/ (x352 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x353 => ((x353 = 0%F) \/ (x353 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x354 => ((x354 = 0%F) \/ (x354 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> True -> ((v = 0%F) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation26_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : Z), True -> True -> True -> Forall (fun x355 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x356 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x357 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x358 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x359 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x361 => Forall (fun x360 => True) x361) new_data -> Forall (fun x361 => ((length x361) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x363 => Forall (fun x362 => True) x363) epoch_tree_elements -> Forall (fun x363 => ((length x363) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x365 => Forall (fun x364 => True) x365) epoch_tree_indices -> Forall (fun x365 => ((length x365) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x366 => ((x366 = 0%F) \/ (x366 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x367 => ((x367 = 0%F) \/ (x367 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x368 => ((x368 = 0%F) \/ (x368 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> True -> ((v = 0%nat) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation27_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : Z), True -> True -> True -> Forall (fun x369 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x370 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x371 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x372 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x373 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x375 => Forall (fun x374 => True) x375) new_data -> Forall (fun x375 => ((length x375) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x377 => Forall (fun x376 => True) x377) epoch_tree_elements -> Forall (fun x377 => ((length x377) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x379 => Forall (fun x378 => True) x379) epoch_tree_indices -> Forall (fun x379 => ((length x379) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x380 => ((x380 = 0%F) \/ (x380 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x381 => ((x381 = 0%F) \/ (x381 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x382 => ((x382 = 0%F) \/ (x382 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> True -> (((0%nat <= v) /\ (v = EPOCH_KEY_NONCE_PER_EPOCH)) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation28_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : Z), True -> True -> True -> Forall (fun x383 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x384 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x385 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x386 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x387 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x389 => Forall (fun x388 => True) x389) new_data -> Forall (fun x389 => ((length x389) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x391 => Forall (fun x390 => True) x391) epoch_tree_elements -> Forall (fun x391 => ((length x391) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x393 => Forall (fun x392 => True) x393) epoch_tree_indices -> Forall (fun x393 => ((length x393) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x394 => ((x394 = 0%F) \/ (x394 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x395 => ((x395 = 0%F) \/ (x395 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x396 => ((x396 = 0%F) \/ (x396 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> True -> (((0%nat <= v) /\ (v < EPOCH_KEY_NONCE_PER_EPOCH)) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation29_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (i : nat) (v : (list F)), True -> True -> True -> Forall (fun x397 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x398 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x399 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x400 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x401 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x403 => Forall (fun x402 => True) x403) new_data -> Forall (fun x403 => ((length x403) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x405 => Forall (fun x404 => True) x405) epoch_tree_elements -> Forall (fun x405 => ((length x405) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x407 => Forall (fun x406 => True) x407) epoch_tree_indices -> Forall (fun x407 => ((length x407) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x408 => ((x408 = 0%F) \/ (x408 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x409 => ((x409 = 0%F) \/ (x409 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x410 => ((x410 = 0%F) \/ (x410 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> (i < EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x411 => True) v -> True -> (((length v) = i) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation30_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (i : nat) (__x : (list F)) (v : F), True -> True -> True -> Forall (fun x412 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x413 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x414 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x415 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x416 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x418 => Forall (fun x417 => True) x418) new_data -> Forall (fun x418 => ((length x418) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x420 => Forall (fun x419 => True) x420) epoch_tree_elements -> Forall (fun x420 => ((length x420) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x422 => Forall (fun x421 => True) x422) epoch_tree_indices -> Forall (fun x422 => ((length x422) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x423 => ((x423 = 0%F) \/ (x423 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x424 => ((x424 = 0%F) \/ (x424 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x425 => ((x425 = 0%F) \/ (x425 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> (i < EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x426 => True) __x -> ((length __x) = i) -> True -> ((v = 0%F) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation31_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (i : nat) (__x : (list F)) (v : (list F)), True -> True -> True -> Forall (fun x427 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x428 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x429 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x430 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x431 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x433 => Forall (fun x432 => True) x433) new_data -> Forall (fun x433 => ((length x433) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x435 => Forall (fun x434 => True) x435) epoch_tree_elements -> Forall (fun x435 => ((length x435) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x437 => Forall (fun x436 => True) x437) epoch_tree_indices -> Forall (fun x437 => ((length x437) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x438 => ((x438 = 0%F) \/ (x438 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x439 => ((x439 = 0%F) \/ (x439 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x440 => ((x440 = 0%F) \/ (x440 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> (i < EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x441 => True) __x -> ((length __x) = i) -> Forall (fun x442 => True) v -> True -> ((((length v) = i) /\ (v = __x)) -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation32_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (i : nat) (__x : (list F)) (v : F), True -> True -> True -> Forall (fun x443 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x444 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x445 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x446 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x447 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x449 => Forall (fun x448 => True) x449) new_data -> Forall (fun x449 => ((length x449) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x451 => Forall (fun x450 => True) x451) epoch_tree_elements -> Forall (fun x451 => ((length x451) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x453 => Forall (fun x452 => True) x453) epoch_tree_indices -> Forall (fun x453 => ((length x453) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x454 => ((x454 = 0%F) \/ (x454 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x455 => ((x455 = 0%F) \/ (x455 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x456 => ((x456 = 0%F) \/ (x456 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> (i < EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x457 => True) __x -> ((length __x) = i) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation33: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (i : nat) (__x : (list F)) (v : (list F)), True -> True -> True -> Forall (fun x458 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x459 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x460 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x461 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x462 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x464 => Forall (fun x463 => True) x464) new_data -> Forall (fun x464 => ((length x464) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x466 => Forall (fun x465 => True) x466) epoch_tree_elements -> Forall (fun x466 => ((length x466) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x468 => Forall (fun x467 => True) x468) epoch_tree_indices -> Forall (fun x468 => ((length x468) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x469 => ((x469 = 0%F) \/ (x469 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x470 => ((x470 = 0%F) \/ (x470 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x471 => ((x471 = 0%F) \/ (x471 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> (i < EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x472 => True) __x -> ((length __x) = i) -> Forall (fun x473 => True) v -> True -> ((v = (0%F :: __x)) -> ((length v) = (i + 1%nat)%nat)).
Proof. 
intros. subst.
simpl;auto.
Qed.

Lemma UserStateTransition_obligation34_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (i : nat) (__x : (list F)) (v : F), True -> True -> True -> Forall (fun x474 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x475 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x476 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x477 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x478 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x480 => Forall (fun x479 => True) x480) new_data -> Forall (fun x480 => ((length x480) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x482 => Forall (fun x481 => True) x482) epoch_tree_elements -> Forall (fun x482 => ((length x482) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x484 => Forall (fun x483 => True) x484) epoch_tree_indices -> Forall (fun x484 => ((length x484) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x485 => ((x485 = 0%F) \/ (x485 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x486 => ((x486 = 0%F) \/ (x486 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x487 => ((x487 = 0%F) \/ (x487 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> (i < EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x488 => True) __x -> ((length __x) = i) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation35: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : (list F)), True -> True -> True -> Forall (fun x489 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x490 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x491 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x492 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x493 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x495 => Forall (fun x494 => True) x495) new_data -> Forall (fun x495 => ((length x495) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x497 => Forall (fun x496 => True) x497) epoch_tree_elements -> Forall (fun x497 => ((length x497) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x499 => Forall (fun x498 => True) x499) epoch_tree_indices -> Forall (fun x499 => ((length x499) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x500 => ((x500 = 0%F) \/ (x500 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x501 => ((x501 = 0%F) \/ (x501 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x502 => ((x502 = 0%F) \/ (x502 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> Forall (fun x503 => True) v -> True -> ((v = nil) -> ((length v) = 0%nat)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation36_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : F), True -> True -> True -> Forall (fun x504 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x505 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x506 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x507 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x508 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x510 => Forall (fun x509 => True) x510) new_data -> Forall (fun x510 => ((length x510) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x512 => Forall (fun x511 => True) x512) epoch_tree_elements -> Forall (fun x512 => ((length x512) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x514 => Forall (fun x513 => True) x514) epoch_tree_indices -> Forall (fun x514 => ((length x514) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x515 => ((x515 = 0%F) \/ (x515 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x516 => ((x516 = 0%F) \/ (x516 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x517 => ((x517 = 0%F) \/ (x517 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation37: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : (list F)), True -> True -> True -> Forall (fun x518 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x519 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x520 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x521 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x522 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x524 => Forall (fun x523 => True) x524) new_data -> Forall (fun x524 => ((length x524) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x526 => Forall (fun x525 => True) x526) epoch_tree_elements -> Forall (fun x526 => ((length x526) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x528 => Forall (fun x527 => True) x528) epoch_tree_indices -> Forall (fun x528 => ((length x528) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x529 => ((x529 = 0%F) \/ (x529 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x530 => ((x530 = 0%F) \/ (x530 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x531 => ((x531 = 0%F) \/ (x531 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> Forall (fun x532 => True) v -> True -> (((length v) = EPOCH_KEY_NONCE_PER_EPOCH) -> ((length v) = EPOCH_KEY_NONCE_PER_EPOCH)).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation38_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F) (v : F), True -> True -> True -> Forall (fun x533 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x534 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x535 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x536 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x537 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x539 => Forall (fun x538 => True) x539) new_data -> Forall (fun x539 => ((length x539) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x541 => Forall (fun x540 => True) x541) epoch_tree_elements -> Forall (fun x541 => ((length x541) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x543 => Forall (fun x542 => True) x543) epoch_tree_indices -> Forall (fun x543 => ((length x543) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x544 => ((x544 = 0%F) \/ (x544 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x545 => ((x545 = 0%F) \/ (x545 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x546 => ((x546 = 0%F) \/ (x546 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> True -> (True -> True).
Proof. hammer. Qed.

Lemma UserStateTransition_obligation39_trivial: forall (STATE_TREE_DEPTH : nat) (EPOCH_TREE_DEPTH : nat) (HISTORY_TREE_DEPTH : nat) (EPOCH_KEY_NONCE_PER_EPOCH : nat) (FIELD_COUNT : nat) (SUM_FIELD_COUNT : nat) (REPL_NONCE_BITS : nat) (from_epoch : F) (to_epoch : F) (identity_secret : F) (state_tree_indexes : (list F)) (state_tree_elements : (list F)) (history_tree_indices : (list F)) (history_tree_elements : (list F)) (attester_id : F) (data : (list F)) (new_data : (list (list F))) (epoch_tree_root : F) (epoch_tree_elements : (list (list F))) (epoch_tree_indices : (list (list F))) (from_epoch_check : (list F)) (to_epoch_check : (list F)) (epoch_check : F) (u0 : unit) (attester_id_check : (list F)) (leaf_hasher : F) (state_merkletree : F) (history_leaf_hasher : F) (history_merkletree : F), True -> True -> True -> Forall (fun x547 => True) state_tree_indexes -> ((length state_tree_indexes) = STATE_TREE_DEPTH) -> Forall (fun x548 => True) state_tree_elements -> ((length state_tree_elements) = STATE_TREE_DEPTH) -> Forall (fun x549 => True) history_tree_indices -> ((length history_tree_indices) = HISTORY_TREE_DEPTH) -> Forall (fun x550 => True) history_tree_elements -> ((length history_tree_elements) = HISTORY_TREE_DEPTH) -> True -> Forall (fun x551 => True) data -> ((length data) = FIELD_COUNT) -> Forall (fun x553 => Forall (fun x552 => True) x553) new_data -> Forall (fun x553 => ((length x553) = FIELD_COUNT)) new_data -> ((length new_data) = EPOCH_KEY_NONCE_PER_EPOCH) -> True -> Forall (fun x555 => Forall (fun x554 => True) x555) epoch_tree_elements -> Forall (fun x555 => ((length x555) = EPOCH_TREE_DEPTH)) epoch_tree_elements -> ((length epoch_tree_elements) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x557 => Forall (fun x556 => True) x557) epoch_tree_indices -> Forall (fun x557 => ((length x557) = EPOCH_TREE_DEPTH)) epoch_tree_indices -> ((length epoch_tree_indices) = EPOCH_KEY_NONCE_PER_EPOCH) -> Forall (fun x558 => ((x558 = 0%F) \/ (x558 = 1%F))) from_epoch_check -> (((as_le_f from_epoch_check) = from_epoch) /\ ((length from_epoch_check) = 48%nat)) -> Forall (fun x559 => ((x559 = 0%F) \/ (x559 = 1%F))) to_epoch_check -> (((as_le_f to_epoch_check) = to_epoch) /\ ((length to_epoch_check) = 48%nat)) -> (((epoch_check = 0%F) \/ (epoch_check = 1%F)) /\ (((epoch_check = 1%F) -> ((^ from_epoch) < (^ to_epoch))) /\ ((epoch_check = 0%F) -> ~((^ from_epoch) < (^ to_epoch))))) -> (epoch_check = 1%F) -> Forall (fun x560 => ((x560 = 0%F) \/ (x560 = 1%F))) attester_id_check -> (((as_le_f attester_id_check) = attester_id) /\ ((length attester_id_check) = 160%nat)) -> (leaf_hasher = (Poseidon 3%nat (identity_secret :: ((attester_id + ((2%F ^ 160%nat)%F * from_epoch)%F)%F :: ((u_state_tree_leaf (skipn 1%nat data) (data!0%nat)) :: nil))))) -> ((state_merkletree = (MrklTreeInclPfHash (zip state_tree_indexes state_tree_elements) leaf_hasher)) /\ ~((leaf_hasher = 0%F))) -> (history_leaf_hasher = (Poseidon 2%nat (state_merkletree :: (epoch_tree_root :: nil)))) -> ((history_merkletree = (MrklTreeInclPfHash (zip history_tree_indices history_tree_elements) history_leaf_hasher)) /\ ~((history_leaf_hasher = 0%F))) -> (True -> True).
Proof. hammer. Qed.